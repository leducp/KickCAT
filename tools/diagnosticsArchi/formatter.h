#ifndef SERVER_FORMATTER
#define SERVER_FORMATTER

#include "kickcat/Container.h"
#include "kickcat/CANOpenStateMachine.h"

#include <string>
#include <iostream>

struct ALStatusCodeFormat
{
    uint16_t ALStatusCode;
    const char* meaning;
    const char* desc;
};

struct ALStatusFormat
{
    uint8_t ALStatus;
    const char* name; 
};

ALStatusCodeFormat ALStatusCodeToFormat(uint16_t const& ALStatusCode)
{
    switch(ALStatusCode)
    {
        case 0x0000 : return {0x0000, "No error", "No error"};
        case 0x0001 : return {0x0001, "Unspecified error", "No code error is defined for occurred error"};
        case 0x0002 : return {0x0002, "No memory", "Slave need more memory to perform operation"};
        case 0x0004 : return {0x0004, "Invalid revision", "Output/Input mapping is not valid for this hardware or software revision (0x1018:03)"};
        case 0x0011 : return {0x0011, "Invalid requested state change", "The EtherCAT State Machine (ESM) defines which state changes are allowed. All other state changes are not allowed"};
        case 0x0012 : return {0X0012, "Unknown requested state change", "Undefined state change has been requested"};
        case 0x0013 : return {0x0013, "Boot state not supported", "Device does not support BOOT state, but the master requests the slave to go to BOOT (AL Control = 0x03)"};
        case 0x0014 : return {0x0014, "No valid firmware", "This error code may be returned after a firmware download, if the downloaded file cannot be used by the application controller"};
        case 0x0015 : return {0x0015, "Invalid mailbox configuration", "Invalid mailbox configuration, replace previous network description of old slave with the one of the new slave"};
        case 0x0016 : return {0x0016, "Invalid mailbox configuration", "Example: The slave hardware was replaced while the network configuration remained unchanged. The new hardware expects different mailbox SyncManager settings"};
        case 0x0017 : return {0x0017, "Invalid Sync Manager configuration", "Process data length and SyncManager length may not match, issue a re-calculation of the EtherCAT configuration"};
        case 0x0018 : return {0x0018, "No valid inputs available", "The slave application cannot provide valid input values"};
        case 0x0019 : return {0x0019, "No valid outputs available", "The slave application cannot recieve valid output values"};
        case 0x001A : return {0x001A, "Synchronization error", "If too many RxPDO Toggle error occur, i.e. the RxPDO Toggle Failed Counter increases the internal limit the slave returns to SAFEPERROR with 0x001A. Multiple synchronization errors. Device is not synchronized any more (used if the causes mirrored by the AL Status Codes 0x2C, 0x2D, 0x32, 0x33, 0x34 cannot be distinguished)"};
        case 0x001B : return {0x001B, "Sync manager watchdog", "The slave did not receive process data within the specified watchdog time"};
        case 0x001C : return {0x001C, "Invalid Sync Manager Types", "n/a"};
        case 0x001D : return {0x001D, "Invalid Output Configuration", "SM configuration for output process data is invalid"};
        case 0x001E : return {0x001E, "Invalid Input Configuration", "SM configuration for input process data is invalid"};
        case 0x001F : return {0x001F, "Invalid Watchdog Configuration", "Invalid watchdong configuration, use default WD settings"};
        case 0x0020 : return {0x0020, "Slave need cold start", "Slave device require a power off - power on reset"};
        case 0x0021 : return {0x0021, "Slave needs INIT", "Slave application requests INIT state"};
        case 0x0022 : return {0x0022, "Slave needs PREOP", "Slave application requests PREOP state"};
        case 0x0023 : return {0x0023, "Slave needs SAFEOP", "Slave application requests SAFEOP state"};
        case 0x0024 : return {0x0024, "Invalid Input Mapping", "The process data described by the configuration (PdoConfig) or PDO assignment (PdoAssign) is invalid"};
        case 0x0025 : return {0x0025, "Invalid Output Mapping", "The process data described by the configuration (PdoConfig) or PDO assignment (PdoAssign) is invalid"};
        case 0x0026 : return {0x0026, "Inconsistent Settings", "General settings mismatch"};
        case 0x0027 : return {0x0027, "Freerun not supported", "n/a"};
        case 0x0028 : return {0x0028, "Synchronization not supported", "n/a"};
        case 0x0029 : return {0x0029, "Freerun needs 3 Buffer Mode", "FreeRun mode, SM has to run in 3-buffer mode"};
        case 0x002A : return {0x002A, "Background Watchdog", "n/a"};
        case 0x002B : return {0x002B, "No Valid Inputs and Outputs", "n/a"};
        case 0x002C : return {0x002C, "Fatal Sync Error", "The hardware interrupt signal (so called Sync signal) generated by the ESC is not generated any more"};
        case 0x002D : return {0x002D, "SyncSignal error", "SyncSignal not received: In SAFEOP the slave waits for the first Sync0/Sync1 events before switching to OP, if these events were not received during the SAFEOP to OP-Timeout time the slave refuses the state transition to OP"};
        case 0x0030 : return {0x0030, "Invalid DC SYNC Configuration", "Distributed Clock Configuration is invalid due to application requirements"};
        case 0x0031 : return {0x0031, "Invalid DC Latch Configuration", "DC Latch configuration is invalid due to application requirements"};
        case 0x0032 : return {0x0032, "PLL Error", "Master not synchronized, at least one DC event received"};
        case 0x0033 : return {0x0033, "DC Sync IO Error", "Multiple Synchronization Errors: At least one SycnSignal was received before. However, the PLL between slave and master is not synchronized any more. This may occur if the master application jitters too much"};
        case 0x0034 : return {0x0034, "DC Sync Timeout Error", "Multiple Synchronization Errors, too much SM events missed"};
        case 0x0035 : return {0x0035, "DC Invalid Sync Cycle Time", "n/a"};
        case 0x0036 : return {0x0036, "DC Sync0 Cycle Time", "DC Sync0 cycle time does not fit to the application requirements"};
        case 0x0037 : return {0x0037, "DC Sync1 Cycle Time", "DC Sync1 cycle time does not fit to the application requirements"};
        case 0x0041 : return {0x0041, "MBX_AOE", "n/a"};
        case 0x0042 : return {0x0042, "MBX_EOE", "n/a"};
        case 0x0043 : return {0x0043, "MBX_COE", "n/a"};
        case 0x0044 : return {0x0044, "MBX_FOE", "n/a"};
        case 0x0045 : return {0x0045, "MBX_SOE", "n/a"};
        case 0x004F : return {0x004F, "MBX_VOE", "n/a"};
        case 0x0050 : return {0x0050, "EEPROM No Access", "EEPROM not assigned to PDI"};
        case 0x0051 : return {0x0051, "EEPROM Error", "EEPROM access error"};
        case 0x0060 : return {0x0060, "Slave Requested Locally", "n/a"};
        case 0x0061 : return {0x0061, "Device Identification Value updated", "n/a"};
        case 0x00F0 : return {0x00F0, "Application Controller available", "n/a"};
        default : return {ALStatusCode, "Unknown ALStatusCode", "This status is not referenced in docs from Beckhoff"};
    }
};

ALStatusFormat ALStatusToFormat(uint8_t const& ALStatus)
{
    switch(ALStatus)
    {
        case 0x00 : return {0x00, "Invalid"};
        case 0x01 : return {0X01, "INIT"};
        case 0x02 : return {0x02, "PREOP"};
        case 0x03 : return {0x03, "BOOT"};
        case 0x04 : return {0x04, "SAFEOP"};
        case 0x08 : return {0x08, "OPERATIONNAL"};
        case 0x10 : return {0X10, "ACK"};
        default : return {ALStatus, "Unknown status"};
    }
};

const char* CANStatusToFormat(uint16_t const& statusWord)
{
    if ((statusWord & can::status::value::OFF_STATE) == can::status::value::OFF_STATE) {return "OFF";}
    else if ((statusWord & can::status::value::ON_STATE) == can::status::value::ON_STATE) {return "ON";}
    else if ((statusWord & can::status::value::DISABLED_STATE) == can::status::value::DISABLED_STATE) {return "DISABLED";}
    else if ((statusWord & can::status::value::READY_TO_SWITCH_ON_STATE) == can::status::value::READY_TO_SWITCH_ON_STATE) {return "READY_TO_SWITCH_ON";}
    else if ((statusWord & can::status::value::FAULT_STATE) == can::status::value::FAULT_STATE) {return "FAULT";}
    else return "Unknown";
};

const char* ProcessStateToFormat(processState const& process)
{
    switch(process)
    {
        case processState::DEFAULT_OK :                             {return "DEFAULT_OK";};
        case processState::SOCKET_ERROR :                           {return "SOCKET_ERROR";};
        case processState::NO_SLAVE_DETECTED :                      {return "NO_SLAVE_DETECTED";};
        case processState::SLAVE_DETECTION_OK :                     {return "SLAVE_DETECTION_OK";};
        case processState::UNEXPECTED_TOPOLOGY :                    {return "UNEXPECTED_TOPOLOGY";};
        case processState::TOPOLOGY_OK :                            {return "TOPOLOGY_OK";};

        case processState::RESET_SLAVES_FAILED :                    {return "RESET_SLAVES_FAILED";};
        case processState::RESET_SLAVES_OK :                        {return "RESET_SLAVES_OK";};

        case processState::ECAT_INIT_TIMEOUT :                      {return "ECAT_INIT_TIMEOUT";};
        case processState::ECAT_INIT_INVALID_STATE_TRANSITION :     {return "ECAT_INIT_INVALID_STATE_TRANSITION";};
        case processState::ECAT_INIT_FAILED :                       {return "ECAT_INIT_FAILED";};
        case processState::ECAT_INIT_OK :                           {return "ECAT_INIT_OK";};

        case processState::ECAT_FETCH_EEPROM_TIMEOUT :              {return "ECAT_FETCH_EEPROM_TIMEOUT";};
        case processState::ECAT_FETCH_EEPROM_FAILED :               {return "ECAT_FETCH_EEPROM_FAILED";};
        case processState::ECAT_FETCH_EEPROM_OK :                   {return "ECAT_FETCH_EEPROM_OK";};
        case processState::ECAT_CONFIGURE_MAILBOXES_FAILED :        {return "ECAT_CONFIGURE_MAILBOXES_FAILED";};
        case processState::ECAT_CONFIGURE_MAILBOXES_OK :            {return "ECAT_CONFIGURE_MAILBOXES_OK";};

        case processState::ECAT_PREOP_TIMEOUT :                     {return "ECAT_PREOP_TIMEOUT";};
        case processState::ECAT_PREOP_INVALID_STATE_TRANSITION :    {return "ECAT_PREOP_INVALID_STATE_TRANSITION";};
        case processState::ECAT_PREOP_FAILED :                      {return "ECAT_PREOP_FAILED";};
        case processState::ECAT_PREOP_OK :                          {return "ECAT_PREOP_OK";};

        case processState::ECAT_IO_CHECKMAILBOXES_FAILED :          {return "ECAT_IO_CHECKMAILBOXES_FAILED";};
        case processState::ECAT_IO_RXMAPPING_FAILED :               {return "ECAT_IO_RXMAPPING_FAILED";};
        case processState::ECAT_IO_RXMAPPING_TIMEOUT :              {return "ECAT_IO_RXMAPPING_TIMEOUT";};
        case processState::ECAT_IO_TXMAPPING_FAILED :               {return "ECAT_IO_TXMAPPING_FAILED";};
        case processState::ECAT_IO_TXMAPPING_TIMEOUT :              {return "ECAT_IO_TXMAPPING_TIMEOUT";};
        case processState::ECAT_IO_IOMAPPING_BUFFERTOOSMALL :       {return "ECAT_IO_IOMAPPING_BUFFERTOOSMALL";};
        case processState::ECAT_IO_IOMAPPING_ACCESS_ERROR :         {return "ECAT_IO_IOMAPPING_ACCESS_ERROR";};
        case processState::ECAT_IO_IOMAPPING_TIMEOUT :              {return "ECAT_IO_IOMMAPING_TIMEOUT";};
        case processState::ECAT_IO_IOMAPPING_FAILED :               {return "ECAT_IO_IOMAPPING_FAILED";};
        case processState::ECAT_IO_OK :                             {return "ECAT_IO_OK";};

        case processState::ECAT_SAFEOP_TIMEOUT :                    {return "ECAT_SAFEOP_TIMEOUT";};
        case processState::ECAT_SAFEOP_INVALID_STATE_TRANSITION :   {return "ECAT_SAFEOP_INVALID_TRANSITION";};
        case processState::ECAT_SAFEOP_FAILED :                     {return "ECAT_SAFEOP_FAILED";};
        case processState::ECAT_SAFEOP_OK :                         {return "ECAT_SAFEOP_OK";}; 

        case processState::ECAT_VALIDATE_MAPPING_FAILED :           {return "ECAT_VALIDATE_MAPPING_FAILED";};

        case processState::ECAT_OP_TIMEOUT :                        {return "ECAT_OP_TIMEOUT";};
        case processState::ECAT_OP_INVALID_STATE_TRANSITION :       {return "ECAT_OP_INVALID_STATE_TRANSITION";};
        case processState::ECAT_OP_FAILED :                         {return "ECAT_OP_FAILED";};
        case processState::ECAT_OP_OK :                             {return "ECAT_OP_OK";};

        case processState::CAN_TURNALLON_FAILED :                   {return "CAN_TURNALLON_FAILED";};
        case processState::CAN_TURNALLON_TIMEOUT :                  {return "CAN_TURNALLON_TIMEOUT";};
        case processState::CAN_TURNALLON_OK :                       {return "CAN_TURNALLON_OK";};

        case processState::CAN_TURNALLOFF_FAILED :                  {return "CAN_TURNALLOFF_FAILED";};
        case processState::CAN_TURNALLOFF_TIMEOUT :                 {return "CAN_TURNALLOFF_TIMEOUT";};
        case processState::CAN_TURNALLOFF_OK :                      {return "CAN_TURNALLOFF_OK";};

        case processState::ROUTINE_FAILED :                         {return "ROUTINE_FAILED";};

        case processState::CAN_STEP_INIT_FAILED :                   {return "CAN_STEP_INIT_FAILED";};
        case processState::CAN_STEP_INIT_TIMEOUT :                  {return "CAN_STEP_INIT_TIMEOUT";};
        case processState::CAN_STEP_INIT_OK :                       {return "CAN_STEP_INIT_OK";};

        case processState::UNKNOWN_ERROR :                          {return "UNKNOWN ERROR";};
        default : {return "Data Corrupted at API level";};
    }
}

const char* EcatCommandToFormat(ecatCommand const& command)
{
    switch(command)
    {
        case ecatCommand::BROADCAST_READ :              {return "Broadcast Read";};
        case ecatCommand::BROADCAST_WRITE :             {return "Broadcast Write";};
        case ecatCommand::GET_CURRENT_STATE :           {return "Get Current State";};
        //Init
        case ecatCommand::RESET_SLAVES :                {return "Reset Slaves";};
        case ecatCommand::SET_ADDRESSES :               {return "Set Address";};
        case ecatCommand::REQUEST_ECAT_INIT :           {return "Request eCAT INIT";};
        case ecatCommand::WAIT_ECAT_INIT :              {return "Wait eCAT INIT";};
        //Eeprom
        case ecatCommand::REQUEST_EEPROM :              {return "Request Eeprom";};
        case ecatCommand::READ_EEPROM :                 {return "Read Eeprom";};
        //IO
        case ecatCommand::CONFIGURE_MAILBOXES :         {return "Configure Mailboxes";};
        case ecatCommand::CHECK_MAILBOXES :             {return "Check Mailboxes";};
        case ecatCommand::PROCESS_MAILBOXES :           {return "Process Mailboxes";};
        case ecatCommand::RXMAPPING :                   {return "Set RxMapping";};
        case ecatCommand::TXMAPPING :                   {return "Set TxMapping";};
        case ecatCommand::IOMAPPING :                   {return "Set Inputs/Outputs";};
        //PreOP
        case ecatCommand::REQUEST_ECAT_PREOP :          {return "Request eCAT PREOP";};
        case ecatCommand::WAIT_ECAT_PREOP :             {return "Wait eCAT PREOP";};
        //SafeOP
        case ecatCommand::REQUEST_ECAT_SAFEOP :         {return "Request eCAT SAFEOP";};
        case ecatCommand::WAIT_ECAT_SAFEOP :            {return "Wait eCAT SAFEOP";};
        //Op
        case ecatCommand::VALIDATE_MAPPING :            {return "Validate Mapping (useless read/write operation)";};
        case ecatCommand::REQUEST_ECAT_OP :             {return "Request eCAT OPERATIONNAL";};
        case ecatCommand::WAIT_ECAT_OP :                {return "Wait eCAT OPERATIONNAL";};
        //Logical
        case ecatCommand::SEND_LOGICAL_READ :           {return "Send Logical Read PDO";};
        case ecatCommand::SEND_LOGICAL_WRITE :          {return "Send Logical Write PDO";};
        //Routine
        case ecatCommand::ROUTINE_GENERAL :             {return "Unspecified - Send routine-related command";};
        case ecatCommand::ROUTINE_LOGICALREAD :         {return "[Routine] Send Logical Read PDO";};
        case ecatCommand::ROUTINE_LOGICALWRITE :        {return "[Routine] Send Logical Write PDO";};
        case ecatCommand::ROUTINE_ERRORCOUNTERS :       {return "[Routine] Refresh Error Counters";};
        case ecatCommand::ROUTINE_MAILREADCHECK :       {return "[Routine] Check Read Mailboxes";};
        case ecatCommand::ROUTINE_MAILREAD :            {return "[Routine] Read Mailboxes";};
        //Debug
        case ecatCommand::SEND_GET_REGISTER :           {return "Send Get Register";};
        case ecatCommand::SEND_WRITE_REGISTER :         {return "Send Write Register";};

        default : {return "Data Corrupted at API level";};
    }
}

const char* DatagramStateToFormat(DatagramState const& status)
{
    switch(status)
    {
        case DatagramState::INVALID_WKC : {return "INVALID_WKC";};
        case DatagramState::LOST : {return "LOST";};
        case DatagramState::NO_HANDLER : {return "NO_HANDLER";};
        case DatagramState::OK : {return "OK";};
        case DatagramState::SEND_ERROR : {return "SEND_ERROR";};
        default : {return "Data Corrupted at API level";};
    }
}

#endif
