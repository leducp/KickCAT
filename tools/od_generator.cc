#include "kickcat/CoE/OD.h"
#include "kickcat/Prints.h"
#include "kickcat/CoE/EsiParser.h"
#include <fstream>
#include <iostream>
#include <memory>

namespace kickcat
{
    constexpr std::string_view OD_POPULATOR_FILE{"od_populator.cc"};

    CoE::Dictionary loadOD(std::string esiFileName)
    {
        CoE::EsiParser parser;
        return parser.load(esiFileName);
    }

    std::string addBeginning()
    {
        std::stringstream result;

        result << "/// This file is auto generated by od_generator.\n\n";

        result << "#include \"kickcat/CoE/OD.h\"\n\n";
        result << "namespace kickcat::CoE\n{\n";
        result << "    CoE::Dictionary createOD()\n    {\n";
        result << "        CoE::Dictionary dictionary;\n\n";

        return result.str();
    }

    std::string addEnding()
    {
        std::stringstream result;
        result << "         return dictionary;\n";
        result << "    }\n}\n";
        return result.str();
    }



    std::string addEntry(CoE::Entry const &entryToAdd)
    {
        if (not CoE::isBasic(entryToAdd.type))
        {
            // TODO support complex type of entry
            THROW_ERROR("Object Dictionary Generator only support basic type for now");
        }

        std::stringstream result;
        result << "            CoE::addEntry(object,";
        result << std::to_string(entryToAdd.subindex) << ",";
        result << std::to_string(entryToAdd.bitlen) << ",";
        result << std::to_string(entryToAdd.access) << ",";
        result << "static_cast<CoE::DataType>(" << std::to_string(static_cast<uint16_t>(entryToAdd.type)) << "),";
        result << "\"" << entryToAdd.description << "\",";

        if(entryToAdd.type == CoE::DataType::VISIBLE_STRING)
        {
            result << "\"";
        }

        result << entryToAdd.dataToString();

        if(entryToAdd.type == CoE::DataType::VISIBLE_STRING)
        {
            result << "\"";
        }
        result << ");\n";

        return result.str();
    }

    std::string addObject(CoE::Object const &objectToAdd)
    {
        std::stringstream result;
        result << "        {\n";
        result << "            static CoE::Object object\n";
        result << "            {\n";
        result << "                0x" << std::hex << objectToAdd.index << std::dec << ",\n";
        result << "                CoE::ObjectCode::" << CoE::toString(objectToAdd.code) << ",\n";
        result << "                \"" << objectToAdd.name << "\",\n";
        result << "                {}\n";
        result << "            };\n";

        for (auto const &entry : objectToAdd.entries)
        {
            result << addEntry(entry);
        }

        result << "            dictionary.push_back(std::move(object));\n";
        result << "        }\n\n";

        return result.str();
    }
}

int main(int argc, char *argv[])
{
    using namespace kickcat;

    if ((argc != 2))
    {
        printf("argc: %d\n", argc);
        printf("usage :    ./od_generator [esi.xml]\n");
        return 1;
    }

    auto dictionary = loadOD(argv[1]);

    std::ofstream f(std::string(OD_POPULATOR_FILE).c_str());

    /// Sort Dictionnary to have more readable source file
    std::sort(dictionary.begin(), dictionary.end(),
              [](CoE::Object &object1, CoE::Object &object2)
              { return object1.index < object2.index; });

    f << addBeginning();
    for (auto const &object : dictionary)
    {
        f << addObject(object);
    }
    f << addEnding();

    f.close();

    return 0;
}
