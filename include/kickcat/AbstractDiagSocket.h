#ifndef KICKCAT_ABSTRACT_DIAG_SOCKET_H
#define KICKCAT_ABSTRACT_DIAG_SOCKET_H

#include "Error.h"
#include "Frame.h"

namespace kickcat
{
    /// \brief   A socket interface for diagnostic interface (cf. ETG.8200)
    /// \details This socket serves as an abstraction on classical socket (UDP, TCP, etc.)
    ///          and shall be able to associate an identifier to income request and reply
    class AbstractDiagSocket
    {
    public:
        AbstractDiagSocket() = default;
        virtual ~AbstractDiagSocket() = default;

        virtual void open() = 0;
        virtual void close() noexcept = 0;

        /// \brief Read data on the network (no protocol check!)
        /// \param frame        Buffer where to store the received data
        /// \param frame_size   Size of the buffer to store data to
        /// \return A tuple with the actual received size (-1 in case of error) and an identifier to associate an answer
        virtual std::tuple<int32_t, uint16_t> recv(uint8_t* frame, int32_t frame_size) = 0;

        /// \brief Send data on the network (no protocol check!)
        /// \param frame        Buffer to send on the network
        /// \param frame_size   Size of the buffer to send on the network
        /// \param id           Identifier to select the destination (generated by recv())
        /// \return The number of bytes sent (-1 in case of error)
        virtual int32_t sendTo(uint8_t const* frame, int32_t frame_size, uint16_t id) = 0;

    protected:
        // Helper to compute next index (aka client identifier) for subclasses
        void nextIndex() { index_ = (index_ + 1) & (mailbox::GATEWAY_MAX_REQUEST -1); }
        uint16_t index_{0};
    };
}

#endif
